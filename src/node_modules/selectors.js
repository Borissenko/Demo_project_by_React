import R from 'ramda'

export const getPhoneById = (state, id) => R.prop(id, state.phones)   //вернет телефон по id из state.phones

export const getPhones = (state, ownProps) => {     //поиск в state наобходимого по id-поиска и по типу категории (брэгд телефона)
  const activeCategoryId = getActiveCategoryId(ownProps)  //+для поиска по типу категории

  // const applySearch = item => R.contains(  //R.contains- проверяет, есть ли строка в подстроке
  //   state.phonesPage.search,     //что проверяем. Фигурирует ли (state.phonesPage.search) как подстрока в строке "name" у (R.prop('name', item))-элемента
  //   R.prop('name', item)
  // )
  const applySearch = item => R.compose(              //а это- поиск без учета регистра
    R.contains(R.toLower(state.phonesPage.search)),
    R.toLower,
    R.prop('name')
  )(item)

  const applyCategory = item => R.equals(    //проверяем, равняется ли category.id внутри этого item'a активной категорией
    getActiveCategoryId(ownProps),
    R.prop('categoryId', item)  //из categoryId берем item и проверяем, равняется ли он activeCategoryId
  )

  const phones = R.compose(
    R.filter(applySearch),   //отфильтровывеем только искомые телефоны, проходя по каждому элементу []
    R.when(R.always(activeCategoryId), R.filter(applyCategory)),    //+для поиска по типу категории. R.always(activeCategoryId)- возвращает activeCategoryId и идентична записи "() => R.always(activeCategoryId)".
    //Итого: КОГДА у нас есть R.always(activeCategoryId), т.е. когда у нас есть активная категория, выполняем filter(applyCategory).
    R.map(id => getPhoneById(state, id))  //получаем [{}] телефонов
  )(state.phonesPage.ids)

  return phones
}

export const getRenderedPhonesLength = state => R.length(state.phonesPage.ids)   //количество товаров, показанных на странице. Получаем из локального Store у страницы

export const getTotalBasketCount = state => R.length(state.basket) //кол-во выбранных товаров

export const getTotalBasketPrice = state => {
  const totalPrice = R.compose(
    R.sum,                      //суммируем цены
    R.pluck('price'),             //изымаем цену =>["цена"]
    R.map(id => getPhoneById(state, id))  // => [{}] карзины
  )(state.basket)
  return totalPrice
}

export const getCategories = state => R.values(state.categories)  //выбирает в [] все values из state.categories

export const getActiveCategoryId = ownProps => R. path(['params', 'id'], ownProps)  //структкра {}, сам объект. Свойства объекта и сам объет мб undefined. Что бы код не упал мы оболачиваем их в path. path будет перед тем, как взять из {} его переменную будет проверять их на undefined"ность. Т.е. на вернется undefined, а код не сломается. Это часто используется при получении свойства в {}.

// Нам нужен массив "1товар-сколько его штук"
export const getBasketPhonesWithCount = state => {
  const uniqueIds = R.uniq(state.basket)   //[], все id из корзины будут без повторений
  const phoneCount = id => R.compose(
    R.length,
    R.filter(basketId => R.equals(id, basketId)) //сравниваем определенный id телефона со всем количеством имеющихся id корзины,фильтруя- оставляя только указанный определенный тип id. \\Короче: создаем [] c однотипным id, длинна этого массива укажет количество одноименного товара, который мы покупаем.
  )(state.basket) //state.basket- изначальная кoрзина, с повторениями id
  const phoneWithCount = phone => R.assoc('count', phoneCount(phone.id), phone)
  const phones = R.compose(
    R.map(phoneWithCount), //добавляет слово "caunt" и колличество телефонов в предыдущий {}
    R.map(id => getPhoneById(state, id)) //получаем телефоны по id из state.phones
  )(uniqueIds)
  return phones
}
